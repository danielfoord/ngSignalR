/*ngSignalR-0.0.5 | 02-02-2016 | Copyright (C) danielfoord MIT License*/
angular.module("ngSignalR",[]).constant("$",window.$).provider("signalr",[function(){"use strict";function a(a,b,d,e){if(angular.isFunction(b)&&angular.isDefined(a))d.call(null,a,b);else if(angular.isFunction(b)&&angular.isUndefined(a))e.call(null,b);else if(!angular.isFunction(b))throw new TypeError(c.callback)}var b=this;b.transports=["webSockets","serverSentEvents","foreverFrame","longPolling"],b.log=!0;var c={callback:"Callback function is not a function",errCallback:"ErrorCallback function is not a function"};b.setTransports=function(a){if(!angular.isArray(a))throw new Error("setTransports expects an 'Array'");b.transports=a},b.getTransports=function(){return b.transports},b.$get=["$rootScope","$q","$",function(d,e,f){var g=b.transports,h=[];return{createHubConnection:function(a,b){if(angular.isDefined(a)){var c;c=angular.isDefined(b)?f.hubConnection(b):f.hubConnection();var d=h;d.push(c);var e=c.createHubProxy(a);return{connection:c,proxy:e}}throw new Error("channel is undefined")},createConnection:function(a,b){if(angular.isDefined(a)){angular.isDefined(b)&&(f.connection.hub.url=b);var c=f.connection[a],d=h;return d.push(c),c}throw new Error("channel is undefined")},stopConnection:function(a){var b=e.defer(),c=h;try{c.splice(c.indexOf(a),1),a.stop(),b.resolve()}catch(d){b.reject(d)}return b.promise},stopAllConnections:function(){var a=e.defer(),b=h;try{for(var c in b)b[c].stop();h=[],a.resolve()}catch(d){a.reject(d)}return a.promise},startHubConnection:function(a){if(angular.isDefined(a)){var b=e.defer();return a.start({transport:g}).done(function(){b.resolve()}),b.promise}throw new Error("connection is undefined")},startConnection:function(){var a=e.defer();return f.connection.hub.start({transport:g}).done(function(){a.resolve()}),a.promise},receiveProxy:function(a,b,d){if(d&&!angular.isFunction(d))throw new TypeError(c.callback);a.on(b,d)},receive:function(a,b,d){if(d&&angular.isFunction(d))a.client[b]=d;else if(d&&!angular.isFunction(d))throw new TypeError(c.callback)},sendProxy:function(a,b,d,e){if(e&&!angular.isFunction(e))throw new TypeError(c.errCallback);e?a.invoke(b,d).fail(e):a.invoke(b,d)},send:function(a,b,d,e){if(e&&!angular.isFunction(e))throw new TypeError(c.errCallback);e?a.server[b](d).fail(e):a.server[b](d)},logging:function(a,b){angular.isUndefined(b)?f.connection.hub.logging=a:b.logging=a},starting:function(b,c){a(c,b,function(a,b){a.starting(b)},function(a){f.connection.hub.starting(a)})},received:function(b,c){a(c,b,function(a,b){a.received(b)},function(a){f.connection.hub.received(a)})},connectionSlow:function(b,c){a(c,b,function(a,b){a.connectionSlow(b)},function(a){f.connection.hub.connectionSlow(a)})},reconnecting:function(b,c){a(c,b,function(a,b){a.reconnecting(b)},function(a){f.connection.hub.reconnecting(a)})},reconnected:function(b,c){a(c,b,function(a,b){a.reconnected(b)},function(a){f.connection.hub.reconnected(a)})},stateChanged:function(b,c){a(c,b,function(a,b){a.stateChanged(b)},function(a){f.connection.hub.stateChanged(a)})},disconnected:function(b,c){a(c,b,function(a,b){a.disconnected(b)},function(a){f.connection.hub.disconnected(a)})},error:function(b,c){a(c,b,function(a,b){a.error(b)},function(a){f.connection.hub.error(a)})}}}]}]);